// Note: typically, attribute editor templates (AE templates) have to be named according to the node type. That's only if you put the file in a path and want
// Maya to detect it automatically. We load this file manually, so naming isn't strict (naming of the procs IS strict, just not of the file). 
// This has the advantage of allowing us to put all our templates in the same file and reuse functionality.

global proc AEPBDTemplate(string $nodeName)
{
    editorTemplate -beginScrollLayout;

    editorTemplate -beginLayout "Simulation settings" -collapse 0;
        editorTemplate -label "Compliance" -annotation "Compliance parameter for the PBD solver, controlling overall softness of the material. Higher values yield softer materials." -addControl "compliance";
        editorTemplate -label "Voxel relaxtion" -annotation "The rigidity of individual voxels." -addControl "vgsRelaxation";
        editorTemplate -label "Voxel edge uniformity" -annotation "The extent to which voxels try to maintain their edge lengths." -addControl "vgsEdgeUniformity";
        editorTemplate -label "VGS iterations" -annotation "Number of iterations in the VGS core loop (note that the VGS core loop is nested in the PBD substep loop)." -addControl "vgsIterations";
        editorTemplate -label "Gravity strength" -annotation "Strength of the gravity force applied to all particles." -addControl "gravityStrength";
    editorTemplate -endLayout;

    editorTemplate -beginLayout "Weight paint settings" -collapse 0;
        editorTemplate -callCustom "AE_createFaceConstraintLow" "AE_updateFaceConstraintLow" "faceConstraintLow";
        editorTemplate -callCustom "AE_createFaceConstraintHigh" "AE_updateFaceConstraintHigh" "faceConstraintHigh";
        editorTemplate -callCustom "AE_createParticleMassLow" "AE_updateParticleMassLow" "particleMassLow";
        editorTemplate -callCustom "AE_createParticleMassHigh" "AE_updateParticleMassHigh" "particleMassHigh";
    editorTemplate -endLayout;

    string $keep[] = {"faceConstraintLow", "faceConstraintHigh", "particleMassLow", "particleMassHigh",
                     "voxelRelaxation", "voxelEdgeUniformity", "vgsIterations", "gravityStrength", "compliance"};
    suppressAttributesExcept($nodeName, $keep);

    editorTemplate -endScrollLayout;
}

global proc AE_createFaceConstraintLow(string $attr)
{
    string $ctrl = "AE_faceConstraintLow_ctrl";
    attrFieldSliderGrp -label "Voxel strain limit (low)" -annotation "Breaking point for voxel interfaces in units of voxel-lengths, lower bound" -attribute $attr -sliderMinValue 0 -sliderMaxValue 5 $ctrl;
}

global proc AE_createFaceConstraintHigh(string $attr)
{
    string $ctrl = "AE_faceConstraintHigh_ctrl";
    attrFieldSliderGrp -label "Voxel strain limit (high)" -annotation "Breaking point for voxel interfaces in units of voxel-lengths, upper bound" -attribute $attr -sliderMinValue 0 -sliderMaxValue 5 $ctrl;
}

global proc AE_createParticleMassLow(string $attr)
{
    string $ctrl = "AE_particleMassLow_ctrl";
    attrFieldSliderGrp -label "Particle mass (low)" -annotation "Mass for particles in this object, lower bound" -attribute $attr -sliderMinValue 0.01 -sliderMaxValue 5 $ctrl;
}

global proc AE_createParticleMassHigh(string $attr)
{
    string $ctrl = "AE_particleMassHigh_ctrl";
    attrFieldSliderGrp -label "Particle mass (high)" -annotation "Mass for particles in this object, upper bound" -attribute $attr -sliderMinValue 0.01 -sliderMaxValue 5 $ctrl;
}

global proc AE_updateFaceConstraintLow(string $attr)
{
    string $ctrl = "AE_faceConstraintLow_ctrl";
    attrFieldSliderGrp -edit -attribute $attr -sliderMinValue 0 -sliderMaxValue 5 $ctrl;
    AE_enforceMinMax($attr, "faceConstraintLow", "faceConstraintHigh");
}

global proc AE_updateFaceConstraintHigh(string $attr)
{
    string $ctrl = "AE_faceConstraintHigh_ctrl";
    attrFieldSliderGrp -edit -attribute $attr -sliderMinValue 0 -sliderMaxValue 5 $ctrl;
    AE_enforceMinMax($attr, "faceConstraintLow", "faceConstraintHigh");
}

global proc AE_updateParticleMassLow(string $attr)
{
    string $ctrl = "AE_particleMassLow_ctrl";
    attrFieldSliderGrp -edit -attribute $attr -sliderMinValue 0.01 -sliderMaxValue 5 $ctrl;
    AE_enforceMinMax($attr, "particleMassLow", "particleMassHigh");
}

global proc AE_updateParticleMassHigh(string $attr)
{
    string $ctrl = "AE_particleMassHigh_ctrl";
    attrFieldSliderGrp -edit -attribute $attr -sliderMinValue 0.01 -sliderMaxValue 5 $ctrl;
    AE_enforceMinMax($attr, "particleMassLow", "particleMassHigh");
}

global proc AE_enforceMinMax(string $attr, string $lowName, string $highName)
{
    string $parts[];
    tokenize($attr, ".", $parts);
    if (size($parts) < 2) { return; }
    string $node = $parts[0];

    string $lowPlug = $node + "." + $lowName;
    string $highPlug = $node + "." + $highName;

    float $lowVal = `getAttr $lowPlug`;
    float $highVal = `getAttr $highPlug`;

    if ($lowVal > $highVal) {
        setAttr $highPlug $lowVal;
    }
    else if ($highVal < $lowVal) {
        setAttr $lowPlug $highVal;
    }
}

global proc AE_createParticleCollisionsEnabled(string $attr)
{
    string $ctrl = "AE_particleCollisionsEnabled_ctrl";
    attrControlGrp -label "Enable Particle Collisions" -annotation "Toggle particle-particle collisions." -attribute $attr $ctrl;
}

global proc AE_updateParticleCollisionsEnabled(string $attr)
{
    string $ctrl = "AE_particleCollisionsEnabled_ctrl";
    attrControlGrp -edit -attribute $attr $ctrl;
}

global proc AE_createPrimitiveCollisionsEnabled(string $attr)
{
    string $ctrl = "AE_primitiveCollisionsEnabled_ctrl";
    attrControlGrp -label "Enable Primitive Collisions" -annotation "Toggle collisions between particles and primitive shapes." -attribute $attr $ctrl;
}

global proc AE_updatePrimitiveCollisionsEnabled(string $attr)
{
    string $ctrl = "AE_primitiveCollisionsEnabled_ctrl";
    attrControlGrp -edit -attribute $attr $ctrl;
}

global proc AEGlobalSolverTemplate(string $nodeName)
{
    editorTemplate -beginScrollLayout;

    editorTemplate -beginLayout "Global Solver Settings" -collapse 0;
        editorTemplate -callCustom "AE_createParticleCollisionsEnabled" "AE_updateParticleCollisionsEnabled" "particleCollisionsEnabled";
        editorTemplate -callCustom "AE_createPrimitiveCollisionsEnabled" "AE_updatePrimitiveCollisionsEnabled" "primitiveCollisionsEnabled";
        editorTemplate -label "Substeps Per Frame" -annotation "Number of simulation substeps to perform per frame. Higher values may yield better results at the cost of performance." -addControl "numSubsteps";
        editorTemplate -label "Particle Friction" -annotation "Friction coefficient applied during particle collisions." -addControl "particleFriction";
    editorTemplate -endLayout;

    editorTemplate -beginLayout "Cache Settings" -collapse 0;
        editorTemplate -label "Cache Frequency" -annotation "Number of frames between cached simulation states. A value of 1 caches every frame." -addControl "cacheFrequency";
        editorTemplate -label "Max Cache Size (MB)" -annotation "Maximum size of the simulation cache in megabytes. When the cache exceeds this size, older cached frames will be discarded." -addControl "maxCacheSize";
    editorTemplate -endLayout;

    string $keep[] = {"numSubsteps", "particleCollisionsEnabled", "primitiveCollisionsEnabled", "particleFriction",
                     "cacheFrequency", "maxCacheSize"};
    suppressAttributesExcept($nodeName, $keep);

    editorTemplate -endScrollLayout;
}

global proc AEVoxelizerNodeTemplate(string $nodeName)
{
    editorTemplate -beginScrollLayout;

    // There are currently no custom controls for the voxelizer node.
    // Suppress everything so as not to show internal attributes that are unusable.
    string $keep[] = {};
    suppressAttributesExcept($nodeName, $keep);

    editorTemplate -endScrollLayout;
}

global proc AEVoxelShapeTemplate(string $nodeName)
{
    editorTemplate -beginScrollLayout;

    // There are currently no custom controls for the voxelizer node.
    // Suppress everything so as not to show internal attributes that are unusable.
    string $keep[] = {};
    suppressAttributesExcept($nodeName, $keep);

    editorTemplate -endScrollLayout;
}

global proc AEBoxColliderTemplate(string $nodeName)
{
    editorTemplate -beginScrollLayout;

    editorTemplate -beginLayout "Box Collider" -collapse 0;
        editorTemplate -label "Width" -addControl "boxWidth";
        editorTemplate -label "Height" -addControl "boxHeight";
        editorTemplate -label "Depth" -addControl "boxDepth";
        editorTemplate -label "Friction" -addControl "friction";
    editorTemplate -endLayout;

    string $keep[] = {"boxWidth", "boxHeight", "boxDepth", "friction"};
    suppressAttributesExcept($nodeName, $keep);

    editorTemplate -endScrollLayout;
}

global proc AESphereColliderTemplate(string $nodeName)
{
    editorTemplate -beginScrollLayout;

    editorTemplate -beginLayout "Sphere Collider" -collapse 0;
        editorTemplate -label "Radius" -addControl "radius";
        editorTemplate -label "Friction" -addControl "friction";
    editorTemplate -endLayout;

    string $keep[] = {"radius", "friction"};
    suppressAttributesExcept($nodeName, $keep);

    editorTemplate -endScrollLayout;
}

global proc AECapsuleColliderTemplate(string $nodeName)
{
    editorTemplate -beginScrollLayout;

    editorTemplate -beginLayout "Capsule Collider" -collapse 0;
        editorTemplate -label "Radius" -addControl "radius";
        editorTemplate -label "Height" -addControl "height";
        editorTemplate -label "Friction" -addControl "friction";
    editorTemplate -endLayout;

    string $keep[] = {"radius", "height", "friction"};
    suppressAttributesExcept($nodeName, $keep);

    editorTemplate -endScrollLayout;
}

global proc AECylinderColliderTemplate(string $nodeName)
{
    editorTemplate -beginScrollLayout;

    editorTemplate -beginLayout "Cylinder Collider" -collapse 0;
        editorTemplate -label "Radius" -addControl "radius";
        editorTemplate -label "Height" -addControl "height";
        editorTemplate -label "Friction" -addControl "friction";
    editorTemplate -endLayout;

    string $keep[] = {"radius", "height", "friction"};
    suppressAttributesExcept($nodeName, $keep);

    editorTemplate -endScrollLayout;
}

global proc AEPlaneColliderTemplate(string $nodeName)
{
    editorTemplate -beginScrollLayout;

    editorTemplate -beginLayout "Plane Collider" -collapse 0;
        editorTemplate -label "Width" -addControl "width";
        editorTemplate -label "Height" -addControl "height";
        editorTemplate -label "Normal" -addControl "normal";
        editorTemplate -label "Infinite" -addControl "infinite";
        editorTemplate -label "Friction" -addControl "friction";
    editorTemplate -endLayout;

    string $keep[] = {"width", "height", "normal", "infinite", "friction"};
    suppressAttributesExcept($nodeName, $keep);

    editorTemplate -endScrollLayout;
}

global proc suppressAttributesExcept(string $nodeName, string $keep[])
{
    string $attrs[] = `listAttr $nodeName`;
    int $i;
    for ($i = 0; $i < size($attrs); $i = $i + 1) {
        string $a = $attrs[$i];
        int $j;
        int $skip = 0;
        for ($j = 0; $j < size($keep); $j = $j + 1) {
            if ($a == $keep[$j]) { $skip = 1; break; }
        }
        if (!$skip) {
            editorTemplate -suppress $a;
        }
    }

    editorTemplate -suppress "worldMatrixIn";
}

// Just going to shove this feature in here for now rather than making a separate file for it.
// It adds a menu item to the timeslider's cache (sub)menu to clear the cubit simulation cache.
global proc cubit_AddResetCacheButtonToTimelineMenu() {
    // Force Maya to build the Time Slider menu
    source "TimeSliderMenu";
    updateTimeSliderMenu TimeSlider|MainTimeSliderLayout|TimeSliderMenu;

    string $menu = "TimeSlider|MainTimeSliderLayout|TimeSliderMenu";
    string $cachedPlaybackMenuItem = cubit_findMenuItemByLabel($menu, "Cached Playback");
    if ($cachedPlaybackMenuItem == "") {
        return;
    }

    string $flushCacheMenuItem = cubit_findMenuItemByLabel($cachedPlaybackMenuItem, "Flush cache");

    menuItem
        -label "Flush cubit (plugin) cache"
        -parent $cachedPlaybackMenuItem
        -insertAfter $flushCacheMenuItem
        -command "cubit_FlushPluginCache();"
        cubitFlushCacheMenuItem;
}

global proc cubit_RemoveResetCacheButtonFromTimelineMenu() {
    string $menu = "TimeSlider|MainTimeSliderLayout|TimeSliderMenu";
    string $cachedPlaybackMenuItem = cubit_findMenuItemByLabel($menu, "Cached Playback");
    if ($cachedPlaybackMenuItem == "") {
        return;
    }

    string $flushCacheMenuItem = cubit_findMenuItemByLabel($cachedPlaybackMenuItem, "Flush cubit (plugin) cache");
    if ($flushCacheMenuItem != "") {
        deleteUI $flushCacheMenuItem;
    }
}

global proc string cubit_findMenuItemByLabel(string $rootMenuOrItem, string $targetLabel)
{
    string $children[];

    // If it's a menu, query its items
    if (`menu -exists $rootMenuOrItem`) {
        $children = `menu -q -itemArray $rootMenuOrItem`;
    }

    // If it's a submenu menuItem, query its items
    else if (`menuItem -exists $rootMenuOrItem` && `menuItem -q -subMenu $rootMenuOrItem`) {
        $children = `menuItem -q -itemArray $rootMenuOrItem`;
    } else {
        return "";
    }

    for ($c in $children) {
        if (!`menuItem -exists $c`) continue;

        string $lbl = `menuItem -q -label $c`;
        if ($lbl == $targetLabel) {
            return $c;
        }

        // Recurse into submenus
        if (`menuItem -q -subMenu $c`) {
            string $hit = cubit_findMenuItemByLabel($c, $targetLabel);
            if ($hit != "") return $hit;
        }
    }

    return "";
}

// Quick-and-dirty way to flush the cache. The global solver has a callback on maxCacheSize changes that flushes the cache.
// So just set the attribute to its current value.
global proc cubit_FlushPluginCache()
{
    string $globalSolverNodes[] = `ls -type "GlobalSolver"`;
    if (size($globalSolverNodes) < 1) {
        return;
    }

    string $globalSolverNode = $globalSolverNodes[0];

    int $maxCacheSize = `getAttr ($globalSolverNode + ".maxCacheSize")`;
    setAttr ($globalSolverNode + ".maxCacheSize") $maxCacheSize;
}