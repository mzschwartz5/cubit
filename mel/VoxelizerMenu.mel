// Create a named instance of the voxel context commands to reuse so they retains user settings
global string $voxelPaintContext;
global string $voxelDragContext;
global int $VOXEL_SUBDIV_SOFTMAX = 32;
global int $VOXEL_SUBDIV_HARDMAX = 64;
global int $VOXEL_SUBDIV_MIN = 2;

global proc VoxelizerMenu() {
    global int $VOXEL_SUBDIV_SOFTMAX;
    global int $VOXEL_SUBDIV_HARDMAX;
    global int $VOXEL_SUBDIV_MIN;

    if (`window -exists VoxelizerMenuWindow`) {
        deleteUI VoxelizerMenuWindow;
    }

    string $selection[] = `ls -selection`;
    if (size($selection) <= 0) {
        warning("No mesh selected to voxelize.");
        return;
    }
    string $selectedMeshName = $selection[0];

    float $initialValues[] = VoxelizerMenu_getInitialVoxelGridValues($selectedMeshName);
    string $voxelGridDisplayName = VoxelizerMenu_createVoxelGridDisplay($selectedMeshName, $initialValues);
    float $gridDisplayExtents[];
    $gridDisplayExtents[0] = `polyCube -q -w $voxelGridDisplayName`;
    $gridDisplayExtents[1] = `polyCube -q -h $voxelGridDisplayName`;
    $gridDisplayExtents[2] = `polyCube -q -d $voxelGridDisplayName`;
    float $voxelMinSizeSoft = max($gridDisplayExtents[0], max($gridDisplayExtents[1], $gridDisplayExtents[2])) / $VOXEL_SUBDIV_SOFTMAX;
    float $voxelMinSizeHard = max($gridDisplayExtents[0], max($gridDisplayExtents[1], $gridDisplayExtents[2])) / $VOXEL_SUBDIV_HARDMAX;
    float $voxelMaxSizeSoft = min($gridDisplayExtents[0], min($gridDisplayExtents[1], $gridDisplayExtents[2])) / $VOXEL_SUBDIV_MIN;

    window -title "Voxelizer Menu" VoxelizerMenuWindow;
    formLayout VoxelizerMenuForm;

    // Instruction text
    string $instructionText = `text -label "Use fields below to control the voxelization, and optionally orient the box in the viewport using the manipulators"`;

    // Spacer for top padding
    string $spacer1 = `separator -style "none" -height 1`;
    string $spacer2 = `separator -style "in" -height 1`;

    // Subdivision controls
    string $constrainCheckbox = `checkBox -label "Lock grid size (best effort)" -value true`;

    string $resizeToBbox = `button -label "Resize to mesh bounds" -command ("VoxelizerMenu_resizeToBbox(\"" + $selectedMeshName + "\", \"" + $voxelGridDisplayName + "\")") -annotation "Resize the grid dimensions while keeping the voxel size constant"`;

    string $gridPropsTitle = `text -label "Voxel Grid:" -align "left" -font "boldLabelFont"`;

    string $voxelSizeField = `floatSliderGrp -label "Voxel Size: " -value $initialValues[6] -field true -minValue $voxelMinSizeSoft -fieldMinValue $voxelMinSizeHard -maxValue $voxelMaxSizeSoft -fieldMaxValue 1e6
        -pre 4 -step 0.0001
        -columnAlign 1 "left" -columnWidth 1 55 -columnWidth 2 50
        -cc ("VoxelizerMenu_updateVoxelSize(\"" + $voxelGridDisplayName + "\", #1, `checkBox -query -value \"" + $constrainCheckbox + "\"`)")
        VoxelSizeField`;

    string $subdivWidthField = `intSliderGrp -label "X Subdivs: " -value $initialValues[7] -field true -minValue $VOXEL_SUBDIV_MIN -maxValue $VOXEL_SUBDIV_SOFTMAX -fieldMinValue $VOXEL_SUBDIV_MIN -fieldMaxValue $VOXEL_SUBDIV_HARDMAX
        -cc ("VoxelizerMenu_updateSubdivisions(\"" + $voxelGridDisplayName + "\", #1, 0, `checkBox -query -value \"" + $constrainCheckbox + "\"`)") 
        -columnAlign 1 "left" -columnWidth 1 55 -columnWidth 2 50
        SubdivWidthField`;

    string $subdivHeightField = `intSliderGrp -label "Y Subdivs: " -value $initialValues[8] -field true -minValue $VOXEL_SUBDIV_MIN -maxValue $VOXEL_SUBDIV_SOFTMAX -fieldMinValue $VOXEL_SUBDIV_MIN -fieldMaxValue $VOXEL_SUBDIV_HARDMAX
        -cc ("VoxelizerMenu_updateSubdivisions(\"" + $voxelGridDisplayName + "\", #1, 1, `checkBox -query -value \"" + $constrainCheckbox + "\"`)") 
        -columnAlign 1 "left" -columnWidth 1 55 -columnWidth 2 50
        SubdivHeightField`;

    string $subdivDepthField = `intSliderGrp -label "Z Subdivs: " -value $initialValues[9] -field true -minValue $VOXEL_SUBDIV_MIN -maxValue $VOXEL_SUBDIV_SOFTMAX -fieldMinValue $VOXEL_SUBDIV_MIN -fieldMaxValue $VOXEL_SUBDIV_HARDMAX
        -cc ("VoxelizerMenu_updateSubdivisions(\"" + $voxelGridDisplayName + "\", #1, 2, `checkBox -query -value \"" + $constrainCheckbox + "\"`)") 
        -columnAlign 1 "left" -columnWidth 1 55 -columnWidth 2 50
        SubdivDepthField`;

    string $advancedOptionsTitle = `text -label "Advanced Options:" -align "left" -font "boldLabelFont"`;
    string $surfaceCheckbox = `checkBox -label "Surface" -value true`;
    string $solidCheckbox = `checkBox -label "Solid" -value true`;
    string $renderAsVoxelsCheckbox = `checkBox -label "Render As Voxels" -value false`;
    string $clipTrianglesCheckbox = `checkBox -label "Clip Triangles" -value false`;

    // Buttons
    string $cancelButton = `button -label "Cancel" -command ("VoxelizerMenu_close(\"" + $voxelGridDisplayName + "\")")`;
    string $runButton = `button -label "Voxelize"
        -annotation "Voxelizes a mesh in preparation for VGS simulation. Uses selected mesh or, if none selected, the closest mesh to the center of the grid bounds."
        -command ("VoxelizerMenu_run(\"" + $voxelGridDisplayName + "\", \"" + $selectedMeshName + "\", \"" + $surfaceCheckbox + "\", \"" + $solidCheckbox + "\", \"" + $renderAsVoxelsCheckbox + "\", \"" + $clipTrianglesCheckbox + "\")")`;

    // Attach elements to form layout 
    formLayout -edit -attachForm $instructionText "top" 10 -attachForm $instructionText "left" 20 -attachForm $instructionText "right" 20 VoxelizerMenuForm;
    formLayout -edit -attachControl $spacer1 "top" 10 $instructionText -attachForm $spacer1 "left" 20 -attachForm $spacer1 "right" 20 VoxelizerMenuForm;
    formLayout -edit -attachForm $gridPropsTitle "left" 20 -attachControl $gridPropsTitle "top" 10 $spacer1 -attachForm $gridPropsTitle "right" 20 VoxelizerMenuForm;
    formLayout -edit -attachForm $voxelSizeField "left" 20 -attachControl $voxelSizeField "top" 10 $gridPropsTitle -attachForm $voxelSizeField "right" 20 VoxelizerMenuForm;
    formLayout -edit -attachForm $subdivWidthField "left" 20 -attachControl $subdivWidthField "top" 10 $voxelSizeField -attachForm $subdivWidthField "right" 20 VoxelizerMenuForm;
    formLayout -edit -attachForm $subdivHeightField "left" 20 -attachControl $subdivHeightField "top" 10 $subdivWidthField -attachForm $subdivHeightField "right" 20 VoxelizerMenuForm;
    formLayout -edit -attachForm $subdivDepthField "left" 20 -attachControl $subdivDepthField "top" 10 $subdivHeightField -attachForm $subdivDepthField "right" 20 VoxelizerMenuForm;
    formLayout -edit -attachForm $constrainCheckbox "left" 20 -attachControl $constrainCheckbox "top" 10 $subdivDepthField -attachForm $constrainCheckbox "right" 20 VoxelizerMenuForm;
    formLayout -edit -attachForm $resizeToBbox "right" 20 -attachControl $resizeToBbox "top" 5 $subdivDepthField VoxelizerMenuForm;
    formLayout -edit -attachControl $spacer2 "top" 10 $resizeToBbox -attachForm $spacer2 "left" 20 -attachForm $spacer2 "right" 20 VoxelizerMenuForm;
    formLayout -edit -attachForm $advancedOptionsTitle "left" 20 -attachControl $advancedOptionsTitle "top" 10 $spacer2 -attachForm $advancedOptionsTitle "right" 20 VoxelizerMenuForm;
    formLayout -edit -attachForm $surfaceCheckbox "left" 20 -attachControl $surfaceCheckbox "top" 10 $advancedOptionsTitle VoxelizerMenuForm;
    formLayout -edit -attachControl $solidCheckbox "left" 10 $surfaceCheckbox -attachControl $solidCheckbox "top" 10 $advancedOptionsTitle VoxelizerMenuForm;
    formLayout -edit -attachControl $renderAsVoxelsCheckbox "left" 10 $solidCheckbox -attachControl $renderAsVoxelsCheckbox "top" 10 $advancedOptionsTitle VoxelizerMenuForm;
    formLayout -edit -attachControl $clipTrianglesCheckbox "left" 10 $renderAsVoxelsCheckbox -attachControl $clipTrianglesCheckbox "top" 10 $advancedOptionsTitle VoxelizerMenuForm;
    formLayout -edit -attachForm $runButton "left" 20 -attachForm $runButton "bottom" 10 -attachControl $runButton "top" 15 $clipTrianglesCheckbox VoxelizerMenuForm;
    formLayout -edit -attachForm $cancelButton "left" 80 -attachForm $cancelButton "bottom" 10 -attachControl $cancelButton "top" 15 $clipTrianglesCheckbox VoxelizerMenuForm;
    
    showWindow VoxelizerMenuWindow;

    // Detect when the window has closed and run the cancel function
    scriptJob -uiDeleted VoxelizerMenuWindow ("VoxelizerMenu_close(\"" + $voxelGridDisplayName + "\")");
}

global proc VoxelizerMenu_run(
    string $cubeName, 
    string $selectedMeshName, 
    string $surfaceCheckbox, 
    string $solidCheckbox, 
    string $renderAsVoxelsCheckbox, 
    string $clipTrianglesCheckbox
) {
    float $posX = `getAttr ($cubeName + ".translateX")`;
    float $posY = `getAttr ($cubeName + ".translateY")`;
    float $posZ = `getAttr ($cubeName + ".translateZ")`;
    float $rotXDeg = `getAttr ($cubeName + ".rotateX")`;
    float $rotYDeg = `getAttr ($cubeName + ".rotateY")`;
    float $rotZDeg = `getAttr ($cubeName + ".rotateZ")`;
    float $rotX = deg_to_rad($rotXDeg);
    float $rotY = deg_to_rad($rotYDeg);
    float $rotZ = deg_to_rad($rotZDeg);

    int $voxelsPerEdgeX = `intSliderGrp -query -value SubdivWidthField`;
    int $voxelsPerEdgeY = `intSliderGrp -query -value SubdivHeightField`;
    int $voxelsPerEdgeZ = `intSliderGrp -query -value SubdivDepthField`;
    float $voxelSize = `floatSliderGrp -query -value VoxelSizeField`;
    int $surface = `checkBox -query -value $surfaceCheckbox`;
    int $solid = `checkBox -query -value $solidCheckbox`;
    int $renderAsVoxels = `checkBox -query -value $renderAsVoxelsCheckbox`;
    int $clipTriangles = `checkBox -query -value $clipTrianglesCheckbox`;
    int $type = $surface + ($solid * 2) + ($renderAsVoxels * 4) + ($clipTriangles * 8); // Convert checkboxes to a single integer

    // Construct the cubit command with the passed arguments
    string $command = "cubit -px " + $posX + " -py " + $posY + " -pz " + $posZ + 
                                    " -rx " + $rotX + " -ry " + $rotY + " -rz " + $rotZ + 
                                    " -vx " + $voxelsPerEdgeX + " -vy " + $voxelsPerEdgeY + " -vz " + $voxelsPerEdgeZ + 
                                    " -vsz " + $voxelSize + " -n \"" + $selectedMeshName + "\"" + " -t " + $type + ";";

    // Execute the command and handle errors
    if (catch(eval($command))) {
        warning("cubit failed.");
    } else {
        VoxelizerMenu_close($cubeName);
    }
}

global proc float[] VoxelizerMenu_getInitialVoxelGridValues(string $selectedMeshName) {
    // First get the bounding box of the selected object
    // The bounding box of an object is axis aligned. We want to get the oriented bounding box, so unrotate the object,
    // get the bounding box, then restore the rotation.
    float $originalRotation[] = `xform -q -ws -rotation $selectedMeshName`;
    xform -ws -rotation 0 0 0 $selectedMeshName;
    float $bbox[] = `xform -q -ws -bb $selectedMeshName`;
    xform -ws -rotation $originalRotation[0] $originalRotation[1] $originalRotation[2] $selectedMeshName;
    float $extents[] = {$bbox[3] - $bbox[0], $bbox[4] - $bbox[1], $bbox[5] - $bbox[2]};
    float $center[] = {(($bbox[3] + $bbox[0]) / 2.0), (($bbox[4] + $bbox[1]) / 2.0), (($bbox[5] + $bbox[2]) / 2.0)};
    
    // Get the shortest extent - divide it into 2 voxels (thus determining the voxel size).
    float $minExtent = min($extents[0], min($extents[1], $extents[2]));
    float $voxelSize = $minExtent / 2.0;
    if ($voxelSize <= 0.0) {
        error("Selected mesh has zero size in at least one dimension.");
    }
    float $eps = 0.0001;
    float $voxelsPerEdge[] = {ceil(($extents[0] / $voxelSize) - $eps), ceil(($extents[1] / $voxelSize) - $eps), ceil(($extents[2] / $voxelSize) - $eps)};

    float $results[] = {$extents[0], $extents[1], $extents[2], 
                        $center[0], $center[1], $center[2],
                        $voxelSize, 
                        $voxelsPerEdge[0], $voxelsPerEdge[1], $voxelsPerEdge[2]};
    return $results;
}

global proc string VoxelizerMenu_createVoxelGridDisplay(string $selectedMeshName, float $initialValues[]) {
    float $cubeExtents[3] = {$initialValues[6] * $initialValues[7], 
                            $initialValues[6] * $initialValues[8], 
                            $initialValues[6] * $initialValues[9]};
    string $voxelGridDisplay[] = `polyCube -n "VoxelGridDisplay" -w $cubeExtents[0] -h $cubeExtents[1] -d $cubeExtents[2]
                                  -sx $initialValues[7] -sy $initialValues[8] -sz $initialValues[9] -ch 1`;
    string $voxelGridDisplayName = $voxelGridDisplay[0];
    float $rotation[] = `xform -q -ws -rotation $selectedMeshName`;
    float $position[] = `xform -q -ws -translation $selectedMeshName`;
    float $pivotWS[] = `xform -q -ws -rotatePivot $selectedMeshName`;

    xform -ws -translation $initialValues[3] $initialValues[4] $initialValues[5] $voxelGridDisplayName;
    xform -ws -rotatePivot $pivotWS[0] $pivotWS[1] $pivotWS[2] $voxelGridDisplayName;
    xform -ws -rotation $rotation[0] $rotation[1] $rotation[2] $voxelGridDisplayName;
    BakeCustomPivot;

    // Hide the cube in the outliner
    setAttr ($voxelGridDisplayName + ".hiddenInOutliner") true;

    // Display the cube in wireframe mode
    setAttr ($voxelGridDisplayName + ".overrideEnabled") true;
    setAttr ($voxelGridDisplayName + ".overrideShading") 0;

    // Lock all attributes except translation
    string $attributes[] = `listAttr -keyable -settable $voxelGridDisplayName`;
    for ($attr in $attributes) {
        if (!(`gmatch $attr "translate*"` || `gmatch $attr "rotate*"`)) {
            setAttr -lock true ($voxelGridDisplayName + "." + $attr);
        }
    }

    // Lock the node to prevent deletion
    lockNode -lock true $voxelGridDisplayName;
    return $voxelGridDisplayName;
}

// Update subdivisions of the polyCube
global proc VoxelizerMenu_updateSubdivisions(string $cubeName, int $subdivs, int $axis, int $constrain) {
    global int $VOXEL_SUBDIV_HARDMAX;
    global int $VOXEL_SUBDIV_MIN;
    string $history[] = `listHistory $cubeName`;
    string $polyCubeNode[] = `ls -type "polyCube" $history`; // Ensure this is treated as an array
    if (size($polyCubeNode) <= 0) return;

    float $eps = 0.0001;
    float $w = `getAttr ($polyCubeNode[0] + ".width")`;
    float $h = `getAttr ($polyCubeNode[0] + ".height")`;
    float $d = `getAttr ($polyCubeNode[0] + ".depth")`;
    float $cubeExtents[3] = {$w, $h, $d};
    
    int $sx = `getAttr ($polyCubeNode[0] + ".subdivisionsWidth")`;
    int $sy = `getAttr ($polyCubeNode[0] + ".subdivisionsHeight")`;
    int $sz = `getAttr ($polyCubeNode[0] + ".subdivisionsDepth")`;
    int $voxelsPerEdge[3] = {$sx, $sy, $sz};

    if ($constrain) {
        // If the user wants to keep the extents (more or less) constant, the voxels per edge must change 
        // to accommodate the new subdivision count on the specified axis. But make sure the voxel size does not go below the minimum.
        float $maxExtent = max($cubeExtents[0], max($cubeExtents[1], $cubeExtents[2]));
        float $minExtent = min($cubeExtents[0], min($cubeExtents[1], $cubeExtents[2]));
        float $voxelMaxSize = $minExtent / $VOXEL_SUBDIV_MIN;
        float $voxelMinSizeHard = $maxExtent / $VOXEL_SUBDIV_HARDMAX;
        float $newVoxelSize = $cubeExtents[$axis] / $subdivs;
       
        if ($newVoxelSize < $voxelMinSizeHard) {
            $newVoxelSize = $voxelMinSizeHard;
        }
        if ($newVoxelSize > $voxelMaxSize) {
            $newVoxelSize = $voxelMaxSize;
        }
        
        $voxelsPerEdge[0] = ceil(($cubeExtents[0] / $newVoxelSize) - $eps);
        $voxelsPerEdge[1] = ceil(($cubeExtents[1] / $newVoxelSize) - $eps);
        $voxelsPerEdge[2] = ceil(($cubeExtents[2] / $newVoxelSize) - $eps);

        // The display grid _is_ constrained, but because we can't have fractional voxels (and they must be cubic), the extents must change slightly to accommodate the new voxel size.
        $cubeExtents[0] = $newVoxelSize * $voxelsPerEdge[0];
        $cubeExtents[1] = $newVoxelSize * $voxelsPerEdge[1];
        $cubeExtents[2] = $newVoxelSize * $voxelsPerEdge[2];

        floatSliderGrp -e -value ($newVoxelSize) VoxelSizeField;
    } else {
        float $voxelSize = $cubeExtents[$axis] / $voxelsPerEdge[$axis];
        float $newExtent = $voxelSize * $subdivs;
        $cubeExtents[$axis] = $newExtent;
        $voxelsPerEdge[$axis] = $subdivs;
    }

    polyCube -e -w $cubeExtents[0] -h $cubeExtents[1] -d $cubeExtents[2] $cubeName;
    polyCube -e -sx $voxelsPerEdge[0] -sy $voxelsPerEdge[1] -sz $voxelsPerEdge[2] $cubeName;
    intSliderGrp -e -value ($voxelsPerEdge[0]) SubdivWidthField;
    intSliderGrp -e -value ($voxelsPerEdge[1]) SubdivHeightField;
    intSliderGrp -e -value ($voxelsPerEdge[2]) SubdivDepthField;
}

global proc VoxelizerMenu_updateVoxelSize(string $cubeName, float $voxelSize, int $constrain) {
    global int $VOXEL_SUBDIV_MIN;
    string $history[] = `listHistory $cubeName`;
    string $polyCubeNode[] = `ls -type "polyCube" $history`; // Ensure this is treated as an array
    if (size($polyCubeNode) <= 0) return;

    float $eps = 0.0001;
    float $w = `getAttr ($polyCubeNode[0] + ".width")`;
    float $h = `getAttr ($polyCubeNode[0] + ".height")`;
    float $d = `getAttr ($polyCubeNode[0] + ".depth")`;
    float $cubeExtents[3] = {$w, $h, $d};
    
    int $sx = `getAttr ($polyCubeNode[0] + ".subdivisionsWidth")`;
    int $sy = `getAttr ($polyCubeNode[0] + ".subdivisionsHeight")`;
    int $sz = `getAttr ($polyCubeNode[0] + ".subdivisionsDepth")`;
    int $voxelsPerEdge[3] = {$sx, $sy, $sz};
    if ($constrain) {
        // If the user wants to keep the extents (more or less) constant, the voxels per edge must change 
        // to accommodate the new voxel size. But make sure the smallest side has at least the minimum subdivisions. (in the case the user types in a value above the slider soft max)
        float $minExtent = min($cubeExtents[0], min($cubeExtents[1], $cubeExtents[2]));
        float $voxelMaxSizeSoft = $minExtent / $VOXEL_SUBDIV_MIN;
        if ($voxelSize > $voxelMaxSizeSoft) {
            $voxelSize = $voxelMaxSizeSoft;
            floatSliderGrp -e -value ($voxelSize) VoxelSizeField;
        }
        $voxelsPerEdge[0] = ceil(($cubeExtents[0] / $voxelSize) - $eps);
        $voxelsPerEdge[1] = ceil(($cubeExtents[1] / $voxelSize) - $eps);
        $voxelsPerEdge[2] = ceil(($cubeExtents[2] / $voxelSize) - $eps);
        polyCube -e -sx $voxelsPerEdge[0] -sy $voxelsPerEdge[1] -sz $voxelsPerEdge[2] $cubeName;
        intSliderGrp -e -value ($voxelsPerEdge[0]) SubdivWidthField;
        intSliderGrp -e -value ($voxelsPerEdge[1]) SubdivHeightField;
        intSliderGrp -e -value ($voxelsPerEdge[2]) SubdivDepthField;
    } else {
        // Otherwise, the extents must change to accommodate the new voxel size.
        $cubeExtents[0] = $voxelSize * $voxelsPerEdge[0];
        $cubeExtents[1] = $voxelSize * $voxelsPerEdge[1];
        $cubeExtents[2] = $voxelSize * $voxelsPerEdge[2];
        polyCube -e -w $cubeExtents[0] -h $cubeExtents[1] -d $cubeExtents[2] $cubeName;
    }
}

global proc VoxelizerMenu_resizeToBbox(string $selectedMeshName, string $cubeName) {
    float $initialValues[] = VoxelizerMenu_getInitialVoxelGridValues($selectedMeshName);
    float $voxelSize = `floatSliderGrp -query -value VoxelSizeField`;
    $initialValues[6] = $voxelSize;
    $initialValues[7] = ceil(($initialValues[0] / $voxelSize) - 0.0001);
    $initialValues[8] = ceil(($initialValues[1] / $voxelSize) - 0.0001);
    $initialValues[9] = ceil(($initialValues[2] / $voxelSize) - 0.0001);

    lockNode -lock false $cubeName;
    delete $cubeName;
    VoxelizerMenu_createVoxelGridDisplay($selectedMeshName, $initialValues);

    intSliderGrp -e -value ($initialValues[7]) SubdivWidthField;
    intSliderGrp -e -value ($initialValues[8]) SubdivHeightField;
    intSliderGrp -e -value ($initialValues[9]) SubdivDepthField;
}

// Cancel and delete the voxel grid
global proc VoxelizerMenu_close(string $cubeName) {
    if (`objExists $cubeName`) {
        // Unlock the node if it is locked
        lockNode -lock false $cubeName;
        // Delete the node
        delete $cubeName;
    }
    // Close the menu
    if (`window -exists VoxelizerMenuWindow`) {
        deleteUI VoxelizerMenuWindow;
    }
}

global proc VoxelizerMenu_initializeUI() {
    VoxelizerMenu_addToShelf();
    VoxelizerMenu_addMenu();
    cubit_AddResetCacheButtonToTimelineMenu();
}

global proc VoxelizerMenu_addToShelf() {
    global string $voxelPaintContext;
    global string $voxelDragContext;
    $voxelPaintContext = `voxelPaintContextCommand`;
    $voxelDragContext = `voxelDragContextCommand`;
    // Ensure the "cubit" shelf exists
    global string $gShelfTopLevel;
    if (!`shelfLayout -exists "cubit"`) {
        shelfLayout -p $gShelfTopLevel "cubit";
    }

    // Get all buttons in the "cubit" shelf
    string $buttons[] = `shelfLayout -query -childArray "cubit"`;

    // Check if the "cubit" button already exists
    int $exists = 0;
    for ($button in $buttons) {
        if (`shelfButton -query -label $button` == "cubit") {
            $exists = 1;
            break;
        }
    }

    // Add the "cubit" button if it doesn't exist
    if (!$exists) {
        shelfButton -parent "cubit"
            -label "cubit"
            -annotation "Run cubit Plugin"
            -image1 "Voxelize.png"
            -command "VoxelizerMenu();";
        
        // Also add a button for the live-interaction tool
        shelfButton -parent "cubit"
            -label "VoxelDragTool"
            -annotation "Interactively drag voxels in the viewport while previewing an animation"
            -image1 "VoxelDrag.png"
            -command "setToolTo $voxelDragContext;"
            -doubleClickCommand "setToolTo $voxelDragContext; toolPropertyWindow;";

        shelfButton -parent "cubit"
            -label "VoxelCollider"
            -annotation "Add a collider primitive to the simulation"
            -image1 "VoxelCollider.png"
            -command "createCollider -n PlaneCollider;"
            -menuItem "Plane Collider" "createCollider -n PlaneCollider;"
            -menuItem "Sphere Collider" "createCollider -n SphereCollider;"
            -menuItem "Capsule Collider" "createCollider -n CapsuleCollider;"
            -menuItem "Box Collider" "createCollider -n BoxCollider;"
            -menuItem "Cylinder Collider" "createCollider -n CylinderCollider;";

        shelfButton -parent "cubit"
            -label "VoxelPaintTool"
            -annotation "Paint simulation weights onto voxels"
            -image1 "VoxelPaint.png"
            -command "setToolTo $voxelPaintContext;"
            -doubleClickCommand "setToolTo $voxelPaintContext; toolPropertyWindow;";
    }

    shelfTabLayout -edit -selectTab "cubit" $gShelfTopLevel;
}

// Top-level cubit menu (only option right now is to export)
global proc VoxelizerMenu_addMenu() {
    global string $gMainWindow;

    if (`menu -exists CubitMenu`) {
        deleteUI CubitMenu;
    }

    string $parentMenu = `menu -label "cubit" -tearOff false -parent $gMainWindow CubitMenu`;

    menuItem
        -parent $parentMenu
        -label "Export to Alembic"
        -annotation "Export the current scene via Alembic"
        -command "VoxelizerMenu_kickOffAlembicExport();"
        cubitExportMenuItem;
}

global proc VoxelizerMenu_kickOffAlembicExport() {
    int $loaded = `pluginInfo -q -loaded "AbcExport"`;
    if (!$loaded) {
        if (catchQuiet(`loadPlugin "AbcExport"`)) {
            warning("Failed to load AbcExport plugin. Enable it in Plug-in Manager (AbcExport.mll).");
            return;
        }
    }

    string $voxelShapes[] = `ls -type "VoxelShape"`;
    for ($voxelShape in $voxelShapes) {
        setAttr ($voxelShape + ".exporting") 1;
    }

    AlembicExportAll;

    for ($voxelShape in $voxelShapes) {
        setAttr ($voxelShape + ".exporting") 0;
    }
}

global proc VoxelizerMenu_tearDownUI() {
    if (`shelfLayout -exists "cubit"`) {
        deleteShelfTabNoPrompt("cubit");
    }

    if (`menu -exists CubitMenu`) {
        deleteUI CubitMenu;
    }

    cubit_RemoveResetCacheButtonFromTimelineMenu();
}